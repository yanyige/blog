<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>jQuery源码分析 (第三部分)</title>
  <meta name="description" content="第三章 Sizzle选择器">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2017/03/10/jQuery%E6%BA%90%E7%A0%81-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86.html">
  <link rel="alternate" type="application/rss+xml" title="@YANYIGE" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">@YANYIGE</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1 id="第三章-sizzle选择器">第三章 Sizzle选择器</h1>

<p>Sizzle 是一款纯JavaScript 实现的CSS 选择器引擎，它具有以下特性：</p>

<ul>
  <li>完全独立，无库依赖。</li>
  <li>相较于大多数常用选择器其性能非常有竞争力。</li>
  <li>压缩和开启 gzip 后只有 4 KB。</li>
  <li>具有高扩展性和易于使用的 API。</li>
  <li>支持多种浏览器，如 IE 6.0+、Firefox 3.0+、Chrome 5+、Safari 3+、Opera 9+。</li>
</ul>

<p>W3C Selectors API 规范定义了方法querySelector()和querySelectorAll()，它们用于根据CSS选择器规范定位文档中的元素，但是老版本的浏览器（如IE6、IE7）不支持这两个方法。在Sizzle 内部，如果浏览器支持方法querySelectorAll()，则调用该方法查找元素，如果不支持，则模拟该方法的行为。</p>

<h2 id="31-总体结构">3.1 总体结构</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>(function(){
    // 选择器引擎入口，查找与选择器表达式 selector 匹配的元素集合
    var Sizzle = function( selector, context, results, seed ) { ... };
    // 工具方法，排序、去重
    Sizzle.uniqueSort = function( results ) { ... };
    // 便捷方法，使用指定的选择器表达式 expr 对元素集合 set 进行过滤
    Sizzle.matches = function( expr, set ) { ... };
    // 便捷方法，检查某个元素 node 是否匹配选择器表达式 expr
    Sizzle.matchesSelector = function( node, expr ) { ... };
    // 内部方法，对块表达式进行查找
    Sizzle.find = function( expr, context, isXML ) { ... };
    // 内部方法，用块表达式过滤元素集合
    Sizzle.filter = function( expr, set, inplace, not ) { ... };
    // 工具方法，抛出异常
    Sizzle.error = function( msg ) { ... };
    // 工具方法，获取 DOM 元素集合的文本内容
    var getText = Sizzle.getText = function( elem ) { ... };
    // 扩展方法和属性
    var Expr = Sizzle.selectors = {
    // 块表达式查找顺序
    order: [ "ID", "NAME", "TAG" ],
    // 正则表达式集，用于匹配和解析块表达式
    match: { ID, CLASS, NAME, ATTR, TAG, CHILD, POS, PSEUDO },
    leftMatch: { ... },
    // 属性名修正函数集
    attrMap: { "class", "for" },
    // 属性值读取函数集
    attrHandle: { href, type },
    // 块间关系过滤函数集
    relative: { "+", "&gt;", "", "~" },
    // 块表达式查找函数集
    find: { ID, NAME, TAG },
    // 块表达式预过滤函数集
    preFilter: { CLASS, ID, TAG, CHILD, ATTR, PSEUDO, POS },
    // 伪类过滤函数集
    filters: { enabled, disabled, checked, selected, parent, empty, has, header,
    text, radio, checkbox, file, password, submit, image, reset, button, input,
    focus },
    // 位置伪类过滤函数集
    setFilters: { first, last, even, odd, lt, gt, nth, eq },
    // 块表达式过滤函数集
    filter: { PSEUDO, CHILD, ID, TAG, CLASS, ATTR, POS }
    };
    // 如果支持方法 querySelectorAll()，则调用该方法查找元素
    if ( document.querySelectorAll ) {
        (function(){
            var oldSizzle = Sizzle;
            Sizzle = function( query, context, extra, seed ) {
                // 尝试调用方法 querySelectorAll() 查找元素
                // 如果上下文是 document，则直接调用 querySelectorAll() 查找元素
                return makeArray( context.querySelectorAll(query ), extra );
                // 如果上下文是元素，则为选择器表达式增加上下文，然后调用querySelectorAll()
                // 查找元素
                return makeArray( context.querySelectorAll( "[id='" + nid + "'] " +
                query ), extra );
                // 如果查找失败，则仍然调用 oldSizzle()
                return oldSizzle(query, context, extra, seed);
            };
        })();
    }
    // 如果支持方法 matchesSelector()，则调用该方法检查元素是否匹配选择器表达式
    (function(){
        var matches = html.matchesSelector
        || html.mozMatchesSelector
        || html.webkitMatchesSelector
        || html.msMatchesSelector;
        // 如果支持方法 matchesSelector()
        if ( matches ) {
            Sizzle.matchesSelector = function( node, expr ) {
                // 尝试调用方法 matchesSelector()
                var ret = matches.call( node, expr );
                return ret;
                // 如果查找失败，则仍然调用 Sizzle()
                return Sizzle(expr, null, null, [node]).length &gt; 0;
            };
        }
    })();
    // 检测浏览器是否支持 getElementsByClassName()
    (function(){
        Expr.order.splice(1, 0, "CLASS");
        Expr.find.CLASS = function( match, context, isXML ) { ... };
    })();
    // 工具方法，检测元素 a 是否包含元素 b
    Sizzle.contains = function( a, b ) { ... };
})();
</code></pre>
</div>

<h2 id="32-选择器表达式">3.2 选择器表达式</h2>
<p>为了准确描述Sizzle 的实现，避免歧义，需要先约定一些相关术语，具体如下所示。</p>

<p>序号 | 术语 | 说明和示例
—|—|—
1 | 选择器表达 | CSS 选择器表达式，例如，”div&gt;p”
2 | 并列选择器表达 | 逗号分割的多个选择器表达式，例如，”div, p”
3 | 块表达式 | 例如，”div&gt;p” 中的”div”、”p”
4 | 块表达式类型 | 例如，”div” 的类型是TAG，”.red” 的类型是CLASS，”div.red” 则是TAG +CLASS。共有8 种块表达式类型：ID、CLASS、NAME、ATTR、TAG、CHILD、POS、PSEUDO
5 | 块间关系符 | 表示块表达式之间关系的符号，例如，”div&gt;p” 中的”&gt;”。共有4 种块间关系符： “&gt;” 父子关系、”” 祖先后代关系、”+” 紧挨着的兄弟元素、” ～ “ 之后的所有兄弟
元素</p>

<h2 id="33-设计思路">3.3 设计思路</h2>
<p>在正式开始分析Sizzle 的源码实现之前，先来讨论和分析下如果要执行一段选择器表达式，或者说设计一个简化版的选择器引擎，需要做些什么工作。下面以”div.red&gt;p”为例来模拟执行过程，具体来说有从左向右查找和从右向左查找两种思路：</p>
<ul>
  <li>1）从左向右：先查找”div.red” 匹配的元素集合，然后查找匹配”p” 的子元素集合。</li>
  <li>2）从右向左：先查找”p”匹配的元素集合，然后检查其中每个元素的父元素是否匹配”div.red”。</li>
</ul>

<p>Sizzle，它是一款从右向左查找的选择器引擎，提供了与前面3个步骤相对应的核心接口：</p>
<ul>
  <li>正则 chunker 负责从选择器表达式中提取块表达式和块间关系符。</li>
  <li>方法 Sizzle.find( expr,context,isXML)负责查找块表达式匹配的元素集合，方法Sizzle.filter( expr, set, inplace, not ) 负责用块表达式过滤元素集合。</li>
  <li>对象Sizzle.selector.relative中的块间关系过滤函数根据块间关系符过滤元素集合。函数Sizzle( selector, context, results, seed ) 则按照前面3 个步骤将这些核心接口组织起来。本节对选择器引擎和Sizzle的设计思路作了探索和概述，接下来看看Sizzle 的源码实现。</li>
</ul>

<h2 id="34-sizzle-selector-context-results-seed-">3.4 Sizzle( selector, context, results, seed )</h2>
<p>函数Sizzle( selector, context, results, seed )用于查找与选择器表达式selector匹配的元素集合。该函数是选择器引擎的入口。</p>

<p>函数Sizzle( selector, context, results, seed ) 执行的6个关键步骤如下：</p>
<ul>
  <li>解析块表达式和块间关系符。</li>
  <li>如果存在位置伪类，则从左向右查找：</li>
  <li>
    <ol>
      <li>查找第一个块表达式匹配的元素集合，得到第一个上下文元素集合。</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>遍历剩余的块表达式和块间关系符，不断缩小上下文元素集合。</li>
    </ol>
  </li>
  <li>否则从右向左查找：</li>
  <li>
    <ol>
      <li>查找最后一个块表达式匹配的元素集合，得到候选集、映射集。</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>遍历剩余的块表达式和块间关系符，对映射集执行块间关系过滤。
根据映射集筛选候选集，将最终匹配的元素放入结果集。
如果存在并列选择器表达式，则递归调用Sizzle( selector, context, results, seed )查找匹配的元素集合，并合并、排序、去重。</li>
    </ol>
  </li>
  <li>最后返回结果集。</li>
</ul>

<p>接下来是源码实现：</p>

<h3 id="1-定义sizzle-selector-context-results-seed-">1. 定义Sizzle( selector, context, results, seed )</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>3879 var Sizzle = function( selector, context, results, seed ) {
</code></pre>
</div>

<ul>
  <li>参数 selector：CSS 选择器表达式。</li>
  <li>参数context：DOM元素或文档对象，作为查找元素的上下文，用于限定查找范围。默认
值 是当前文档对象。</li>
  <li>参数 results：可选的数组或类数组，函数 Sizzle( selector, context, results, seed ) 将把查找到的元素添加到其中。</li>
  <li>参数seed：可选的元素集合，函数Sizzle( selector, context, results, seed )将从该元素集合中过滤出匹配选择器表达式的元素集合。</li>
  <li>
    <h3 id="2-修正参数resultscontext">2. 修正参数results、context</h3>
  </li>
</ul>

<p>相关代码如下所示：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>3880 results = results || [];
3881 context = context || document;
3882
3883 var origContext = context;
3884
3885 if ( context.nodeType !== 1 &amp;&amp; context.nodeType !== 9 ) {
3886    return [];
3887 }
3888
3889 if ( !selector || typeof selector !== "string" ) {
3890    return results;
3891 }
3892
</code></pre>
</div>
<h3 id="3-定义局部变量">3. 定义局部变量</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>3893 var m, set, checkSet, extra, ret, cur, pop, i,
3894 prune = true,
3895 contextXML = Sizzle.isXML( context ),
3896 parts = [],
3897 soFar = selector;
3898
</code></pre>
</div>

<ul>
  <li>变量 m：用于存放正则 chunker 每次匹配选择器表达式 selector 的结果。</li>
  <li>变量 set：在从右向左的查找方式中，变量set称为“候选集”，是最后一个块表达式匹配的元素集合，其他块表达式和块间关系符则会对候选集set 进行过滤；对于从左向右的查找方式，变量set 是当前块表达式匹配的元素集合，也是下一个块表达式的上下文。</li>
  <li>变量 checkSet：对于从右向左的查找方式，变量 checkSet称为“映射集”，其初始值是候选集set 的副本，其他块表达式和块间关系符则会对映射集checkSet进行过滤，过滤时先根据块间关系符将其中的元素替换为父元素、祖先元素或兄弟元素，然后把与块表达式不匹配的元素替换为false，最后根据映射集checkSet 筛选候选集set；对于从右向左的查找方式，事实上在查找过程中并不涉及变量checkSet，只是在函数Sizzle() 的最后为了统一筛选和合并匹配元素的代码，将变量checkSet 与变量set 指向了同一个数组。</li>
  <li>变量extra：用于存储选择器表达式中第一个逗号之后的其他并列选择器表达式。如果存在并列选择器表达式，则会递归调用函数Sizzle( selector, context, results, seed )查找匹配元素集合，并执行合并、排序和去重操作。</li>
  <li>变量 ret ：只在从右向左执行方式中用到，用于存放查找器 Sizzle.find( expr,context,isXML ) 对最后一个块表达式的查找结果，格式为{ expr:“…”, set: array }。</li>
  <li>变量 pop：只在从右向左的查找方式中用到，表示单个块表达式。</li>
  <li>变量 prune：只在从右向左的查找方式中用到，表示候选集 set 是否需要筛选，默认为
true，表示需要筛选，如果选择器表达式中只有一个块表达式，则变量prune 为false。</li>
  <li>变量 contextXML：表示上下文 context 是否是 XML 文档。</li>
  <li>变量 parts：存放了正则 chunker 从选择器表达式中提取的块表达式和块间关系符。</li>
  <li>变量soFar：用于保存正则chunker每次从选择器表达式中提取了块表达式或块间关系符后
的剩余部分，初始值为完整的选择器表达式。</li>
</ul>

<h3 id="4-解析块表达式和块间关系符">4. 解析块表达式和块间关系符</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>3860 var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ &gt;+~,(\[\\]+)+|[&gt;+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
3899 // Reset the position of the chunker regexp (start from head)
3900 do {
3901    chunker.exec( "" );
3902    m = chunker.exec( soFar );
3903    
3904    if ( m ) {
3905        soFar = m[3];
3906        
3907        parts.push( m[1] );
3908    
3909        if ( m[2] ) {
3910            extra = m[3];
3911            break;
3912        }
3913    }
3914 } while ( m );
3915
</code></pre>
</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">@YANYIGE</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              @YANYIGE
            
            </li>
            
            <li><a href="mailto:yige.yan@qq.com">yige.yan@qq.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/yanyige"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">yanyige</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/honeyayahaha"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">honeyayahaha</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>欢迎来到我的个人博客，这里会更新关于我的一切~ 欢迎订阅！
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
